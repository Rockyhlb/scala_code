package com.hlb

/**
 * 3.1主要介绍函数式编程基础中的函数定义和高阶函数
 * Created by IntelliJ IDEA.
 * User: 麦田里的乌鸦
 * Date: 2023 / 9 / 16
 * Time: 11:20
 **/

object test {
  //                          _ooOoo_                          //\n\
  //                         o8888888o                         //\n\
  //                         88\" . \"88                         //\n\
  //                         (| ^_^ |)                         //\n\
  //                         O\\  =  /O                         //\n\
  //                      ____/`---'\\____                      //\n\
  //                    .'  \\\\|     |//  `.                    //\n\
  //                   /  \\\\|||  :  |||//  \\                   //\n\
  //                  /  _||||| -:- |||||-  \\                  //\n\
  //                  |   | \\\\\\  -  /// |   |                  //\n\
  //                  | \\_|  ''\\---/''  |   |                  //\n\
  //                  \\  .-\\__  `-`  ___/-. /                  //\n\
  //                ___`. .'  /--.--\\  `. . ___                //\n\
  //               ."" '<  `.___\\_<|>_/___.'  >'"".                //\n\
  //            | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |            //\n\
  //            \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /            //\n\
  //     ========`-.____`-.___\\_____/___.-`____.-'========     //\n\
  //                          `=---='                          //\n\
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     //\n\
  //           佛祖保佑       永不宕机     永无BUG             //\n\

  //  def main(args: Array[String]): Unit = {
  //    // 3.1.1 函数字面量
  ///*
  //    字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面
  //    量、字符串字面量、符号字面量、函数字面量和元组字面量。
  //
  //    &nbsp&nbsp
  //    ● 函数字面量可以体现函数式编程的核心理念。
  //    ● 在非函数式编程语言里，函数的定义包含了“函数类型”和“值”两种层
  //    面的内容。
  //    ● 但是，在函数式编程中，函数是“头等公民”，可以像任何其他数据类型
  //    一样被传递和操作，也就是说，函数的使用方式和其他数据类型的使用方
  //    式完全一致了。
  //    ● 这时，我们就可以像定义变量那样去定义一个函数，由此导致的结果是,
  //    函数也会和其他变量一样，开始有“值”。
  //    ● 就像变量的“类型”和“值”是分开的两个概念一样，函数式编程中，函
  //    数的“类型”和“值”也成为两个分开的概念，函数的“值”，就是“函
  //    数字面量’
  //*/
  //  }
  //}

  //                          _ooOoo_                          //\n\
  //                         o8888888o                         //\n\
  //                         88\" . \"88                         //\n\
  //                         (| ^_^ |)                         //\n\
  //                         O\\  =  /O                         //\n\
  //                      ____/`---'\\____                      //\n\
  //                    .'  \\\\|     |//  `.                    //\n\
  //                   /  \\\\|||  :  |||//  \\                   //\n\
  //                  /  _||||| -:- |||||-  \\                  //\n\
  //                  |   | \\\\\\  -  /// |   |                  //\n\
  //                  | \\_|  ''\\---/''  |   |                  //\n\
  //                  \\  .-\\__  `-`  ___/-. /                  //\n\
  //                ___`. .'  /--.--\\  `. . ___                //\n\
  //               ."" '<  `.___\\_<|>_/___.'  >'"".                //\n\
  //            | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |            //\n\
  //            \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /            //\n\
  //     ========`-.____`-.___\\_____/___.-`____.-'========     //\n\
  //                          `=---='                          //\n\
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     //\n\
  //           佛祖保佑       永不宕机     永无BUG             //\n\

//  def main(args: Array[String]): Unit = {
//    // 3.1.2 函数的类型和值
//
//    class couter(var value: Int) {
//      def counter(int: Int): Int = {
//        value += int
//        value
//      }
//
//      // 上面定义这个函数的类型如下：(Int) => Int
//      // 实际上，只有多个参数时,圆括号才是必须的,当参数只有一个时，圆括号可以省略，如下：Int => Int
//      // 上面就得到了函数的类型
//
//      // 我们只需要把函数定义中的类型声明部分去除，剩下的
//      // 就是函数的"值"，如下：(int) => {value += int}
//    }
///*    现在，我们再按照定义变量的方式，采用Scala语法来定义一个函数。
//      声明一个变量时，我们采用的形式是:
//      val num: Int = 5 //当然，Int类型声明也可以省略，因为Scala具有自动推断类型的功能
//      我们也可以按照上面类似的形式来定义Scala中的函数:
//      val counter: Int => Int = { (value) => value += 1 }
//      从上面可以看出，在Scala中， 函数已经是“头等公民”，单独剥离出来了
//      “值”的概念，-一个函数“值"就是函数字面量。这样，我们只要在某个需
//      要声明函数的地方声明一个函数类型，在调用的时候传一个对应的函数字面
//      量即可，和使用普通变量一模一样。
//      */
//  }
//}

  //                          _ooOoo_                          //\n\
  //                         o8888888o                         //\n\
  //                         88\" . \"88                         //\n\
  //                         (| ^_^ |)                         //\n\
  //                         O\\  =  /O                         //\n\
  //                      ____/`---'\\____                      //\n\
  //                    .'  \\\\|     |//  `.                    //\n\
  //                   /  \\\\|||  :  |||//  \\                   //\n\
  //                  /  _||||| -:- |||||-  \\                  //\n\
  //                  |   | \\\\\\  -  /// |   |                  //\n\
  //                  | \\_|  ''\\---/''  |   |                  //\n\
  //                  \\  .-\\__  `-`  ___/-. /                  //\n\
  //                ___`. .'  /--.--\\  `. . ___                //\n\
  //               ."" '<  `.___\\_<|>_/___.'  >'"".                //\n\
  //            | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |            //\n\
  //            \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /            //\n\
  //     ========`-.____`-.___\\_____/___.-`____.-'========     //\n\
  //                          `=---='                          //\n\
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     //\n\
  //           佛祖保佑       永不宕机     永无BUG             //\n\

//  def main (args: Array[String] ): Unit = {
//    // 3.1.3 匿名函数、Lamda表达式与闭包  &nbsp&nbsp
//    // 我们不需要给每个函数命名，这里就可以使用匿名函数，
//    // 例如：(num:Int) => num * 2
//    // 我们也称上面这种匿名函数的定义形式为“Lamda表达式”
//    // 格式为：(参数) => 表达式  // 如果参数只有一个，参数的圆括号可以省略
//    // 我们可以把匿名函数存放到变量中
//
//    // 这里我们直接把匿名函数定义成一个值，存放到function变量中
//    val function: Int => Int = (num:Int) => num * 2
//    println("res = " + function(23))
//    // Scala具有类型推断机制，可以自动推断变量类型：
//    val function1 = (num: Int) => num * 2
//    println("res1 = " + function1(21))
//    val function2:Int => Int = (num) => num * 2
//    println("res2 = " + function1(20))
//    println
//
//    // 闭包是一个函数，一种比较特殊的函数
//    // 普通函数：val addMore = (x: Int) => x > 0
//    // 闭  包 :  val addMore = (x: Int) => x + more (半封闭状态，more可以改变)
//    var more = 1
//    val addMore = (x: Int) => x + more
//    println(addMore(1))
//    more = 5
//    println(addMore(1))
//    // 每次addMore函数被调用时都会创建一个新的闭包
//    // 每个闭包都会访问闭包创建时活跃的more变量
//  }
//}

  //                          _ooOoo_                          //\n\
  //                         o8888888o                         //\n\
  //                         88\" . \"88                         //\n\
  //                         (| ^_^ |)                         //\n\
  //                         O\\  =  /O                         //\n\
  //                      ____/`---'\\____                      //\n\
  //                    .'  \\\\|     |//  `.                    //\n\
  //                   /  \\\\|||  :  |||//  \\                   //\n\
  //                  /  _||||| -:- |||||-  \\                  //\n\
  //                  |   | \\\\\\  -  /// |   |                  //\n\
  //                  | \\_|  ''\\---/''  |   |                  //\n\
  //                  \\  .-\\__  `-`  ___/-. /                  //\n\
  //                ___`. .'  /--.--\\  `. . ___                //\n\
  //               ."" '<  `.___\\_<|>_/___.'  >'"".                //\n\
  //            | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |            //\n\
  //            \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /            //\n\
  //     ========`-.____`-.___\\_____/___.-`____.-'========     //\n\
  //                          `=---='                          //\n\
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     //\n\
  //           佛祖保佑       永不宕机     永无BUG             //\n\

  def main (args: Array[String] ): Unit = {
    // 3.1.4 占位符与语法   &nbsp&nbsp
    // 为了让函数字面量更加简洁，我们可以使用下划线作为一个或多个参数的占
    // 位符，只要每个参数在函数字面量内仅出现一次。
    val numList = List(-1,-2,0,1,2)
    numList.filter(x => x > 0).foreach(println)
    // 返回1，2,因此可以看出：x => x > 0 等价于 _ > 0
    numList.filter(_ > 0).foreach(println)

    // 如果是 _ + _ ,编译器无法判断缺失的参数类型
    val res = (_: Int) + (_: Int)
    println(res(3,2))
/*
    请留心_+_将扩展成带两个参数的函数字面量。这也是仅当每个参数在函数
    字面量中最多出现一次的情况下你才能运用这种短格式的原由。多个下划线
    指代多个参数，而不是单个参数的重复运用。第一个下划线代表第一个参数，
    第二个下划线代表第二个，第三.....，. 如此类推。
*/
  }
}

